# 동적 프로그래밍   
#### algorithm3/matrixchain/Example4.java 반복문 구현 (행렬의 수 = n)    
// 곱해야할 행렬이 1개   
for (i = 0; i < n; ++i)   
  최소값[i][i] = 0;   
   
// 곱해야할 행렬이 2개   
for (i = 0; i < n-1; ++i)   
  최소값[i][i+1] = (행렬[i].row * 행렬[i].col * 행렬[i+1].col);   
   
// 곱해야할 행렬이 3개      
for (i = 0; i < n-2; ++i)   
    a = 최소값[i+1][i+2] + (행렬[i].행 * 행렬[i].열 * 행렬[i+2].열);  // m[i] * (m[i+1] * m[i+2])   
    g = 최소값[i][i+1] + (행렬[i].행 * 행렬[i+1].열 * 행렬[i+2].열);  // (m[i] * m[i+1]) * m[i+2]   
    최소값[i][i+2] = min(a, b);   

// 곱해야할 행렬이 4개   
for (i = 0; i < n-3; ++i)   
    a = 최소값[i+1][i+3] + (행렬[i].행 * 행렬[i].열 * 행렬[i+3].열);  // m[i] * (m[i+1] * m[i+2] * m[i+3])   
    b = 최소값[i][i+1] + 최소값[i+2][i+3] +
                         (행렬[i].행 * 행렬[i+1].열 * 행렬[i+3].열);  // (m[i] * m[i+1]) * (m[i+2] * m[i+3])   
    c = 최소값[i][i+2] + (행렬[i].행 * 행렬[i+2].열 * 행렬[i+3].열);  // (m[i] * m[i+1] * m[i+2]) * m[i+3]   
    최소값[i][i+3] = min(a, b, c);   

// 곱해야할 행렬이 4개 (다르게 표현)   
for (i = 0; i < n-3; ++i)   
    a = 최소값[i][i] + 최소값[i+1][i+3] + 
                         (행렬[i].행 * 행렬[i].열 * 행렬[i+3].열);    // m[i] * (m[i+1] * m[i+2] * m[i+3])   
    b = 최소값[i][i+1] + 최소값[i+2][i+3] +
                         (행렬[i].행 * 행렬[i+1].열 * 행렬[i+3].열);  // (m[i] * m[i+1]) * (m[i+2] * m[i+3])   
    c = 최소값[i][i+2] + 최소값[i+3][i+3] +
                         (행렬[i].행 * 행렬[i+2].열 * 행렬[i+3].열); // (m[i] * m[i+1] * m[i+2]) * m[i+3]   
    최소값[i][i+3] = min(a, b, c);   

   
// 곱해야할 행렬이 4개 (다르게 표현)   
for (i = 0; i < n-3; ++i)   
    최소 = MAX   
    for (m = 0; m < 3; ++m)   
        temp = 최소값[i][i+m] + 최소값[i+m+1][i+3] +
                                  (행렬[i].행 * 행렬[i+m].열 * 행렬[i+3].열);   
        if (temp < 최소) 최소 = temp;   
    최소값[i][i+3] = 최소;   


// 곱해야할 행렬이 d+1개   
for (i = 0; i < n-d; ++i)   
    최소 = MAX   
    for (m = 0; m < d; ++m)   
        temp = 최소값[i][i+m] + 최소값[i+m+1][i+d] +
                                  (행렬[i].행 * 행렬[i+m].열 * 행렬[i+d].열);   
        if (temp < 최소) 최소 = temp;   
    최소값[i][i+d] = 최소;   

// 종합   
for (d = 1; d < n; ++d)      
    for (i = 0; i < n-d; ++i)   
        최소 = MAX   
        for (m = 0; m < d; ++m)   
            temp = 최소값[i][i+m] + 최소값[i+m+1][i+d] +
                                      (행렬[i].행 * 행렬[i+m].열 * 행렬[i+d].열);   
            if (temp < 최소) 최소 = temp;   
        최소값[i][i+d] = 최소;   
   
