# 동적 프로그래밍   
### 행렬 곱셈   
#### 1. 행렬 연산    
(1) 덧셈, 뺄셈  
행렬의 덧셈과 뺄셈은 두 행렬의 행과 열이 일치할 때만 가능하다.   

(2) 곱셈  
행렬의 곱셈은 왼쪽 행렬의 열과 오른쪽 행렬의 행이 일치할 때만 가능하다.  
a[2][3] * b[3][2] = c[2][2]  

**행렬의 곱셈에 포함된 곱하기 계산의 횟수**  
왼쪽 행렬의 행 × 왼쪽 행렬의 열 × 오른쪽 행렬의 열  

**곱셈 결과 행렬의 크기**  
new 행렬 행 = 왼쪽 행렬 행   
new 행렬 열 = 오른쪽 행렬 열  

(3) 결합 법칙    
+, × : 결합 법칙이 성립한다.  
-, % : 결합 법칙이 성립하지 않는다.  

(4) 효율적인 행렬 곱셈  
행렬의 곱셈은 어떤 순서로 하느냐에 따라서 계산의 수가 달라진다.  

**예)** 
- 계산 #1  
  (A[3][2] x B[2][200]) x C[200][2]  
= AB[3][200] x C[200][2]  
= ABC[3][2]  </br>  
A 행렬 x B 행렬 곱셈에서 곱하기 계산의 수 = 3 x 2 x 200 = 1200  
AB 행렬 x C 행렬 곱셈에서 곱하기 계산의 수 = 3 x 200 x 2 = 1200  
1200 + 1200 = 2400회  

- 계산 #2  
  A[3][2] x (B[2][200] x C[200][2])  
= A[3][2] x BC[2][2]  
= ABC[3][2]  </br>  
B 행렬 x C 행렬 곱셈에서 곱하기 계산의 수 = 2 x 200 x 2 = 800  
A 행렬 x BC 행렬 곱셈에서 곱하기 계산의 수 = 3 x 2 x 2 = 12  
800 + 12 = 812 회  

둘의 계산 결과는 동일하다.     


#### 2. 행렬 곱셈 순서 문제  
(1) 재귀적 문제 해결   
문제 - 곱셈횟수최소값(a, start, end) 구현  
</br> 
  a 배열은 Matrix 객체 배열이다. start, end 는 a 배열의 인덱스이다.  
  이 배열의 start ~ end 위치의 Matrix를 전부 곱할 때,   
  행렬을 곱하는 순서에 따라 정수 곱하기 계산 횟수가 다르다.  
  정수 곱하기 계산 횟수가 가장 작은 순서를 찾아서, 정수 곱하기 계산 횟수를 리턴한다.  
  즉 a 배열의 start ~ end 위치의 행렬을 전부 곱하기 위해 필요한 정수 곱셈 횟수의 최소값을 리턴한다.  


- 이전 단계의 답은 제공되었다고 가정함  
     곱셈횟수최소값(a, start, middle)  
     곱셈횟수최소값(a, middle+1, end)   
     호출 가능함  

- 현 단계의 작업을 구현함   
```  
     for (int middle = start; middle < end; ++middle) {  
        int 횟수1 = 곱셈횟수최소값(a, start, middle)  
        int 횟수2 = 곱셈횟수최소값(a, middle+1, end)   
        int 횟수3 = a[start].row * a[middle].col * a[end].col  
        int 총곱셈횟수 = 휫수1 + 횟수2 + 횟수3  
     }  
```    
총곱셈횟수의 최소값을 찾아서 리턴한다.  

횟수1 = a 배열에서 start~midlle 위치의 행렬을 전부 곱하기 위해 필요한 정수 곱셈 횟수 최소값  
횟수2 = a 배열에서 middle+1 ~ end 위치의 행렬을 전부 곱하기 위해 필요한 정수 곱셈 횟수 최소값  
횟수3 = (start ~ middle) 위치의 행렬을 전부 곱한 결과 행렬과  
       (middle+1 ~ end) 위치의 행렬을 전부 곱한 결과 행렬을 곱하기 위해 필요한 정수 곱셈의 횟수  

- 종료 조건을 구현함 (이전 단계가 없는 단계의 작업 구현)     
     if (start == end) 이면, 행렬 한 개인 경우 곱셈을 할 수 없으므로 return 0;   


**algorithm3/matrixchain/Example1.java 구현**  

(재귀호출 순서 및 동적 프로그래밍 설명 생략)
</br>  
</br>  

### algorithm3/matrixchain/Example4.java 반복문 구현 (행렬의 수 = n)    
// 곱해야할 행렬이 1개   
for (i = 0; i < n; ++i)   
  최소값[i][i] = 0;   
   
// 곱해야할 행렬이 2개   
for (i = 0; i < n-1; ++i)   
  최소값[i][i+1] = (행렬[i].row * 행렬[i].col * 행렬[i+1].col);   
   
// 곱해야할 행렬이 3개      
for (i = 0; i < n-2; ++i)   
    a = 최소값[i+1][i+2] + (행렬[i].행 * 행렬[i].열 * 행렬[i+2].열);  // m[i] * (m[i+1] * m[i+2])   
    g = 최소값[i][i+1] + (행렬[i].행 * 행렬[i+1].열 * 행렬[i+2].열);  // (m[i] * m[i+1]) * m[i+2]   
    최소값[i][i+2] = min(a, b);   

// 곱해야할 행렬이 4개   
for (i = 0; i < n-3; ++i)   
    a = 최소값[i+1][i+3] + (행렬[i].행 * 행렬[i].열 * 행렬[i+3].열);  // m[i] * (m[i+1] * m[i+2] * m[i+3])   
    b = 최소값[i][i+1] + 최소값[i+2][i+3] +
                         (행렬[i].행 * 행렬[i+1].열 * 행렬[i+3].열);  // (m[i] * m[i+1]) * (m[i+2] * m[i+3])   
    c = 최소값[i][i+2] + (행렬[i].행 * 행렬[i+2].열 * 행렬[i+3].열);  // (m[i] * m[i+1] * m[i+2]) * m[i+3]   
    최소값[i][i+3] = min(a, b, c);   

// 곱해야할 행렬이 4개 (다르게 표현)   
for (i = 0; i < n-3; ++i)   
    a = 최소값[i][i] + 최소값[i+1][i+3] + 
                         (행렬[i].행 * 행렬[i].열 * 행렬[i+3].열);    // m[i] * (m[i+1] * m[i+2] * m[i+3])   
    b = 최소값[i][i+1] + 최소값[i+2][i+3] +
                         (행렬[i].행 * 행렬[i+1].열 * 행렬[i+3].열);  // (m[i] * m[i+1]) * (m[i+2] * m[i+3])   
    c = 최소값[i][i+2] + 최소값[i+3][i+3] +
                         (행렬[i].행 * 행렬[i+2].열 * 행렬[i+3].열); // (m[i] * m[i+1] * m[i+2]) * m[i+3]   
    최소값[i][i+3] = min(a, b, c);   

   
// 곱해야할 행렬이 4개 (다르게 표현)   
for (i = 0; i < n-3; ++i)   
    최소 = MAX   
    for (m = 0; m < 3; ++m)   
        temp = 최소값[i][i+m] + 최소값[i+m+1][i+3] +
                                  (행렬[i].행 * 행렬[i+m].열 * 행렬[i+3].열);   
        if (temp < 최소) 최소 = temp;   
    최소값[i][i+3] = 최소;   


// 곱해야할 행렬이 d+1개   
for (i = 0; i < n-d; ++i)   
    최소 = MAX   
    for (m = 0; m < d; ++m)   
        temp = 최소값[i][i+m] + 최소값[i+m+1][i+d] +
                                  (행렬[i].행 * 행렬[i+m].열 * 행렬[i+d].열);   
        if (temp < 최소) 최소 = temp;   
    최소값[i][i+d] = 최소;   

// 종합   
for (d = 1; d < n; ++d)      
    for (i = 0; i < n-d; ++i)   
        최소 = MAX   
        for (m = 0; m < d; ++m)   
            temp = 최소값[i][i+m] + 최소값[i+m+1][i+d] +
                                      (행렬[i].행 * 행렬[i+m].열 * 행렬[i+d].열);   
            if (temp < 최소) 최소 = temp;   
        최소값[i][i+d] = 최소;   
   
